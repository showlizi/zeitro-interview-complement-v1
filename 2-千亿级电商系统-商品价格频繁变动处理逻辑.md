# 千亿级电商系统 - 商品价格频繁变动处理逻辑与流程图

## 目录

- [1. 价格系统架构设计](#1-价格系统架构设计)
- [2. 高频价格更新技术方案](#2-高频价格更新技术方案)
- [3. 价格数据一致性保证](#3-价格数据一致性保证)
- [4. Go语言核心实现](#4-go语言核心实现)
- [5. 性能监控与运维](#5-性能监控与运维)

---

## 1. 价格系统架构设计

### 1.1 整体架构

```mermaid
graph TB
    subgraph "接入层"
        A1[价格管理后台]
        A2[API网关]
        A3[批量导入]
    end
    
    subgraph "服务层"
        B1[价格服务]
        B2[策略引擎]
        B3[事件发布器]
    end
    
    subgraph "数据层"
        C1[当前价格缓存Redis]
        C2[价格历史数据库]
        C3[事件队列Kafka]
    end
    
    subgraph "下游系统"
        D1[搜索引擎ES]
        D2[推荐系统]
        D3[营销系统]
    end
    
    A1 --> B1
    A2 --> B1
    A3 --> B1
    B1 --> B2
    B1 --> B3
    B1 --> C1
    B1 --> C2
    B3 --> C3
    C3 --> D1
    C3 --> D2
    C3 --> D3
```

### 1.2 价格表结构设计

```sql
-- 当前生效价格表（热数据）
CREATE TABLE `product_current_prices` (
    `sku_id` BIGINT UNSIGNED NOT NULL,
    `original_price` DECIMAL(12,2) NOT NULL,
    `sale_price` DECIMAL(12,2) NOT NULL,
    `member_price` DECIMAL(12,2) NULL,
    `currency` VARCHAR(3) NOT NULL DEFAULT 'CNY',
    `price_version` BIGINT UNSIGNED NOT NULL DEFAULT 1,
    `effective_time` TIMESTAMP NOT NULL,
    `updated_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (`sku_id`),
    KEY `idx_price_version` (`price_version`),
    KEY `idx_updated_at` (`updated_at`)
) ENGINE=InnoDB COMMENT='当前生效价格表';

-- 价格变更历史表（冷数据）
CREATE TABLE `product_price_history` (
    `history_id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    `sku_id` BIGINT UNSIGNED NOT NULL,
    `old_price` DECIMAL(12,2) NULL,
    `new_price` DECIMAL(12,2) NOT NULL,
    `change_reason` VARCHAR(200) NULL,
    `price_version` BIGINT UNSIGNED NOT NULL,
    `operator_id` BIGINT UNSIGNED NOT NULL,
    `created_at` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (`history_id`),
    KEY `idx_sku_created` (`sku_id`, `created_at`)
) ENGINE=InnoDB COMMENT='价格变更历史表';
```

---

## 2. 高频价格更新技术方案

### 2.1 价格更新主流程

```mermaid
sequenceDiagram
    participant Admin as 管理员
    participant API as 价格API
    participant Cache as Redis缓存
    participant DB as 数据库
    participant MQ as 消息队列
    participant ES as 搜索引擎
    
    Admin->>API: 1. 价格变更请求
    API->>Cache: 2. 乐观锁检查版本
    API->>DB: 3. 开启事务
    API->>DB: 4. 插入历史记录
    API->>DB: 5. 更新当前价格
    API->>DB: 6. 提交事务
    API->>Cache: 7. 更新缓存
    API->>MQ: 8. 发布变更事件
    API-->>Admin: 9. 返回结果
    MQ->>ES: 10. 异步更新索引
```

### 2.2 批量价格更新流程

```mermaid
flowchart TD
    A[批量价格文件] --> B[文件解析]
    B --> C[数据校验]
    C --> D{校验通过?}
    D -->|否| E[返回错误报告]
    D -->|是| F[分批处理]
    F --> G[批量数据库更新]
    G --> H[批量缓存更新]
    H --> I[批量发送事件]
    I --> J[异步索引更新]
    J --> K[返回处理结果]
```

### 2.3 事件驱动架构

```mermaid
graph LR
    A[价格变更] --> B[发布事件]
    B --> C[Kafka集群]
    C --> D[缓存更新消费者]
    C --> E[索引更新消费者]
    C --> F[通知消费者]
    D --> G[Redis]
    E --> H[Elasticsearch]
    F --> I[下游系统]
```

---

## 3. 价格数据一致性保证

### 3.1 数据一致性策略

```mermaid
stateDiagram-v2
    [*] --> DatabaseUpdate
    DatabaseUpdate --> CacheUpdate
    CacheUpdate --> EventPublish
    EventPublish --> IndexUpdate
    IndexUpdate --> ConsistencyCheck
    
    state ConsistencyCheck {
        [*] --> CheckDB
        CheckDB --> CheckCache
        CheckCache --> CheckIndex
        CheckIndex --> [*]
    }
    
    ConsistencyCheck --> [*]: 一致
    ConsistencyCheck --> RepairData: 不一致
    RepairData --> [*]
```

### 3.2 补偿机制

```mermaid
flowchart TD
    A[检测到数据不一致] --> B[确定权威数据源]
    B --> C[数据库为准]
    C --> D[修复Redis缓存]
    D --> E[修复ES索引]
    E --> F[记录修复日志]
    F --> G[发送告警通知]
```

---

## 4. Go语言核心实现

### 4.1 价格服务核心代码

```go
// 价格服务主结构
type PriceService struct {
    db          *gorm.DB
    redis       *redis.Client
    kafka       *kafka.Writer
    rateLimiter *rate.Limiter
}

// 乐观锁更新价格
func (ps *PriceService) UpdatePrice(ctx context.Context, req *PriceUpdateRequest) error {
    // 1. 获取当前版本
    currentVersion, err := ps.getCurrentVersion(ctx, req.SkuID)
    if err != nil {
        return err
    }
    
    // 2. 版本冲突检查
    if currentVersion != req.ExpectedVersion {
        return errors.New("version conflict")
    }
    
    // 3. 数据库更新
    newVersion := currentVersion + 1
    err = ps.db.Transaction(func(tx *gorm.DB) error {
        // 插入历史记录
        history := &PriceHistory{
            SkuID:       req.SkuID,
            OldPrice:    req.OldPrice,
            NewPrice:    req.NewPrice,
            Version:     newVersion,
            OperatorID:  req.OperatorID,
        }
        if err := tx.Create(history).Error; err != nil {
            return err
        }
        
        // 更新当前价格
        current := &ProductCurrentPrice{
            SkuID:       req.SkuID,
            SalePrice:   req.NewPrice,
            Version:     newVersion,
            UpdatedAt:   time.Now(),
        }
        return tx.Save(current).Error
    })
    
    if err != nil {
        return err
    }
    
    // 4. 更新缓存
    if err := ps.updateCache(ctx, req.SkuID, req.NewPrice, newVersion); err != nil {
        log.Errorf("Failed to update cache: %v", err)
    }
    
    // 5. 发布事件
    event := &PriceChangeEvent{
        SkuID:     req.SkuID,
        OldPrice:  req.OldPrice,
        NewPrice:  req.NewPrice,
        Version:   newVersion,
        Timestamp: time.Now(),
    }
    
    return ps.publishEvent(ctx, event)
}

// 批量价格更新
func (ps *PriceService) BatchUpdatePrices(ctx context.Context, updates []*PriceUpdateRequest) error {
    // 分批处理，避免单次事务过大
    batchSize := 1000
    for i := 0; i < len(updates); i += batchSize {
        end := i + batchSize
        if end > len(updates) {
            end = len(updates)
        }
        
        batch := updates[i:end]
        if err := ps.processBatch(ctx, batch); err != nil {
            return fmt.Errorf("batch %d-%d failed: %v", i, end, err)
        }
    }
    
    return nil
}

// 缓存更新
func (ps *PriceService) updateCache(ctx context.Context, skuID int64, price decimal.Decimal, version int64) error {
    key := fmt.Sprintf("price:current:%d", skuID)
    data := map[string]interface{}{
        "sale_price":    price.String(),
        "price_version": version,
        "updated_at":    time.Now().Unix(),
    }
    
    return ps.redis.HMSet(ctx, key, data).Err()
}

// 事件发布
func (ps *PriceService) publishEvent(ctx context.Context, event *PriceChangeEvent) error {
    data, _ := json.Marshal(event)
    
    message := kafka.Message{
        Topic: "price-change",
        Key:   []byte(fmt.Sprintf("%d", event.SkuID)),
        Value: data,
    }
    
    return ps.kafka.WriteMessages(ctx, message)
}
```

### 4.2 高并发处理

```go
// 价格更新限流器
type PriceRateLimiter struct {
    limiters map[int64]*rate.Limiter
    mutex    sync.RWMutex
}

func (prl *PriceRateLimiter) Allow(skuID int64) bool {
    prl.mutex.RLock()
    limiter, exists := prl.limiters[skuID]
    prl.mutex.RUnlock()
    
    if !exists {
        prl.mutex.Lock()
        limiter = rate.NewLimiter(rate.Limit(10), 10) // 每秒10次更新
        prl.limiters[skuID] = limiter
        prl.mutex.Unlock()
    }
    
    return limiter.Allow()
}

// 协程池处理价格更新
type PriceUpdateWorkerPool struct {
    workerCount int
    jobQueue    chan *PriceUpdateJob
    workers     []*PriceUpdateWorker
}

type PriceUpdateJob struct {
    SkuID    int64
    NewPrice decimal.Decimal
    Callback func(error)
}

func (pool *PriceUpdateWorkerPool) Submit(job *PriceUpdateJob) {
    select {
    case pool.jobQueue <- job:
    default:
        // 队列满时的处理策略
        job.Callback(errors.New("worker pool is full"))
    }
}
```

---

## 5. 性能监控与运维

### 5.1 关键性能指标

```go
// 性能指标收集
type PriceMetrics struct {
    updateLatency     prometheus.HistogramVec
    updateThroughput  prometheus.CounterVec
    cacheHitRate      prometheus.GaugeVec
    versionConflicts  prometheus.CounterVec
}

// 监控指标定义
var (
    PriceUpdateDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "price_update_duration_seconds",
            Help: "Price update duration",
        },
        []string{"operation"},
    )
    
    PriceUpdateTotal = prometheus.NewCounterVec(
        prometheus.CounterOpts{
            Name: "price_update_total",
            Help: "Total price updates",
        },
        []string{"status"},
    )
)
```

### 5.2 运维监控

```mermaid
graph TB
    A[价格系统监控] --> B[性能监控]
    A --> C[错误监控]
    A --> D[业务监控]
    
    B --> B1[更新延迟]
    B --> B2[吞吐量]
    B --> B3[缓存命中率]
    
    C --> C1[更新失败率]
    C --> C2[版本冲突率]
    C --> C3[数据不一致]
    
    D --> D1[价格变更频率]
    D --> D2[热点商品监控]
    D --> D3[批量操作监控]
```

---

## 验收标准

### 功能验收标准
- [ ] 支持单个商品价格秒级更新
- [ ] 支持批量价格更新（万级别）
- [ ] 价格历史完整记录
- [ ] 版本冲突正确处理
- [ ] 数据最终一致性保证

### 性能验收标准
- [ ] 单次价格更新响应时间 < 50ms
- [ ] 批量更新吞吐量 > 1万/秒
- [ ] 缓存命中率 > 95%
- [ ] 数据一致性延迟 < 1秒
- [ ] 系统可用性 > 99.9%

### 可靠性验收标准
- [ ] 价格更新失败率 < 0.1%
- [ ] 版本冲突处理正确率 100%
- [ ] 数据修复成功率 > 99%
- [ ] 告警响应时间 < 1分钟