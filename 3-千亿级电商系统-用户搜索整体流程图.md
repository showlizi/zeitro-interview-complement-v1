# 千亿级电商系统 - 用户搜索整体流程图

## 目录

- [1. 搜索系统架构设计](#1-搜索系统架构设计)
- [2. 搜索请求完整流程](#2-搜索请求完整流程)
- [3. 搜索性能优化策略](#3-搜索性能优化策略)
- [4. Go语言搜索实现](#4-go语言搜索实现)
- [5. 搜索运营与监控](#5-搜索运营与监控)

---

## 1. 搜索系统架构设计

### 1.1 整体架构

```mermaid
graph TB
    subgraph "用户层"
        A1[移动端APP]
        A2[Web浏览器]
        A3[小程序]
    end
    
    subgraph "接入层"
        B1[CDN缓存]
        B2[负载均衡]
        B3[API网关]
    end
    
    subgraph "服务层"
        C1[搜索服务]
        C2[推荐服务]
        C3[个性化服务]
        C4[热词服务]
    end
    
    subgraph "数据层"
        D1[Elasticsearch集群]
        D2[Redis缓存]
        D3[MySQL数据库]
        D4[ClickHouse分析]
    end
    
    subgraph "数据同步"
        E1[Kafka消息队列]
        E2[Canal数据同步]
        E3[Flink实时计算]
    end
    
    A1 --> B1
    A2 --> B1
    A3 --> B1
    B1 --> B2
    B2 --> B3
    B3 --> C1
    C1 --> C2
    C1 --> C3
    C1 --> C4
    
    C1 --> D1
    C1 --> D2
    C2 --> D3
    C3 --> D2
    
    D3 --> E2
    E2 --> E1
    E1 --> E3
    E3 --> D1
```

### 1.2 搜索数据流架构

```mermaid
flowchart LR
    A[商品数据] --> B[Canal监听]
    B --> C[Kafka队列]
    C --> D[Flink处理]
    D --> E[ES索引]
    
    F[用户行为] --> G[日志收集]
    G --> H[实时计算]
    H --> I[用户画像]
    I --> J[个性化搜索]
    
    K[搜索请求] --> L[查询ES]
    L --> M[结果排序]
    M --> N[个性化调整]
    N --> O[返回结果]
```

---

## 2. 搜索请求完整流程

### 2.1 搜索主流程

```mermaid
sequenceDiagram
    participant User as 用户
    participant CDN as CDN缓存
    participant Gateway as API网关
    participant Search as 搜索服务
    participant Cache as Redis缓存
    participant ES as Elasticsearch
    participant Personal as 个性化服务
    participant Analytics as 行为分析
    
    User->>CDN: 1. 发送搜索请求
    CDN->>Gateway: 2. 转发请求
    Gateway->>Search: 3. 路由到搜索服务
    
    Search->>Cache: 4. 查询缓存
    alt 缓存命中
        Cache-->>Search: 5. 返回缓存结果
    else 缓存未命中
        Search->>ES: 6. 查询Elasticsearch
        ES-->>Search: 7. 返回搜索结果
        Search->>Cache: 8. 写入缓存
    end
    
    Search->>Personal: 9. 获取个性化权重
    Personal-->>Search: 10. 返回个性化参数
    
    Search->>Search: 11. 结果排序和过滤
    Search-->>Gateway: 12. 返回最终结果
    Gateway-->>User: 13. 返回搜索结果
    
    par 异步处理
        Search->>Analytics: 记录搜索行为
        Analytics->>Personal: 更新用户画像
    end
```

### 2.2 搜索词处理流程

```mermaid
flowchart TD
    A[用户输入搜索词] --> B[搜索词预处理]
    B --> C[中文分词]
    C --> D[同义词扩展]
    D --> E[拼写纠错]
    E --> F[意图识别]
    F --> G[查询改写]
    G --> H[构建ES查询]
    
    I[搜索建议] --> J[前缀匹配]
    I --> K[热词推荐]
    I --> L[个性化建议]
    
    B --> I
```

### 2.3 搜索结果处理流程

```mermaid
stateDiagram-v2
    [*] --> ESQuery
    ESQuery --> InitialResults
    InitialResults --> PriceInventoryCheck
    PriceInventoryCheck --> PersonalizationScore
    PersonalizationScore --> BusinessRuleFilter
    BusinessRuleFilter --> SortAndRank
    SortAndRank --> Pagination
    Pagination --> ResultAssembly
    ResultAssembly --> [*]
    
    state PriceInventoryCheck {
        [*] --> GetLatestPrice
        GetLatestPrice --> CheckInventory
        CheckInventory --> [*]
    }
    
    state PersonalizationScore {
        [*] --> UserProfile
        UserProfile --> BehaviorWeight
        BehaviorWeight --> RecommendMix
        RecommendMix --> [*]
    }
```

### 2.4 多条件搜索流程

```mermaid
flowchart TD
    A[用户搜索] --> B[解析搜索条件]
    B --> C{搜索类型}
    
    C -->|关键词搜索| D[全文检索]
    C -->|分类搜索| E[分类过滤]
    C -->|品牌搜索| F[品牌过滤]
    C -->|价格区间| G[价格范围过滤]
    
    D --> H[相关性评分]
    E --> H
    F --> H
    G --> H
    
    H --> I[多维度排序]
    I --> J[个性化调整]
    J --> K[结果聚合]
    K --> L[分页处理]
    L --> M[返回结果]
```

---

## 3. 搜索性能优化策略

### 3.1 多级缓存架构

```mermaid
graph TB
    A[搜索请求] --> B[L1-本地缓存]
    B --> C{命中?}
    C -->|是| D[返回结果]
    C -->|否| E[L2-Redis缓存]
    E --> F{命中?}
    F -->|是| G[回写L1+返回]
    F -->|否| H[L3-ES查询]
    H --> I[回写L2+L1]
    I --> J[返回结果]
    
    K[缓存策略] --> L[热词预加载]
    K --> M[结果缓存]
    K --> N[用户缓存]
```

### 3.2 ES索引优化策略

```mermaid
graph LR
    A[索引优化] --> B[分片策略]
    A --> C[副本配置]
    A --> D[映射优化]
    A --> E[查询优化]
    
    B --> B1[按时间分片]
    B --> B2[按地区分片]
    B --> B3[热点数据分片]
    
    C --> C1[读写分离]
    C --> C2[多副本容灾]
    
    D --> D1[字段类型优化]
    D --> D2[分词器选择]
    D --> D3[不索引非搜索字段]
    
    E --> E1[bool查询优化]
    E --> E2[聚合查询优化]
    E --> E3[高亮优化]
```

### 3.3 搜索性能监控

```mermaid
flowchart TD
    A[性能监控] --> B[响应时间监控]
    A --> C[吞吐量监控]
    A --> D[错误率监控]
    A --> E[资源监控]
    
    B --> B1[P99延迟<200ms]
    B --> B2[平均延迟<50ms]
    
    C --> C1[QPS>10万]
    C --> C2[并发用户>100万]
    
    D --> D1[错误率<0.1%]
    D --> D2[超时率<0.01%]
    
    E --> E1[CPU使用率<70%]
    E --> E2[内存使用率<80%]
    E --> E3[磁盘IO<80%]
```

---

## 4. Go语言搜索实现

### 4.1 搜索服务核心实现

```go
// 搜索服务主结构
type SearchService struct {
    esClient    *elasticsearch.Client
    redis       *redis.Client
    localCache  *cache.Cache
    personalSvc *PersonalizationService
    analytics   *AnalyticsService
}

// 搜索请求结构
type SearchRequest struct {
    Query        string            `json:"query"`
    Filters      map[string]interface{} `json:"filters"`
    Sort         []SortField       `json:"sort"`
    Page         int               `json:"page"`
    Size         int               `json:"size"`
    UserID       int64             `json:"user_id"`
    Platform     string            `json:"platform"`
}

// 搜索结果结构
type SearchResponse struct {
    Total       int64           `json:"total"`
    Products    []ProductItem   `json:"products"`
    Aggregations map[string]interface{} `json:"aggregations"`
    Suggestions []string        `json:"suggestions"`
    SearchTime  int64           `json:"search_time"`
}

// 主搜索方法
func (s *SearchService) Search(ctx context.Context, req *SearchRequest) (*SearchResponse, error) {
    startTime := time.Now()
    
    // 1. 参数校验
    if err := s.validateSearchRequest(req); err != nil {
        return nil, err
    }
    
    // 2. 搜索词预处理
    processedQuery, err := s.preprocessQuery(req.Query)
    if err != nil {
        return nil, err
    }
    
    // 3. 缓存查询
    cacheKey := s.generateCacheKey(req)
    if cached, err := s.getFromCache(ctx, cacheKey); err == nil {
        // 异步记录搜索行为
        go s.recordSearchBehavior(ctx, req, cached)
        return cached, nil
    }
    
    // 4. ES查询
    esResp, err := s.searchElasticsearch(ctx, processedQuery, req)
    if err != nil {
        return nil, err
    }
    
    // 5. 个性化处理
    personalizedResp, err := s.applyPersonalization(ctx, esResp, req)
    if err != nil {
        log.Errorf("Personalization failed: %v", err)
        personalizedResp = esResp // 降级处理
    }
    
    // 6. 价格库存实时检查
    finalResp, err := s.enrichWithRealTimeData(ctx, personalizedResp)
    if err != nil {
        return nil, err
    }
    
    // 7. 结果缓存
    finalResp.SearchTime = time.Since(startTime).Milliseconds()
    go s.cacheResult(ctx, cacheKey, finalResp)
    
    // 8. 异步记录行为
    go s.recordSearchBehavior(ctx, req, finalResp)
    
    return finalResp, nil
}

// ES查询实现
func (s *SearchService) searchElasticsearch(ctx context.Context, query string, req *SearchRequest) (*SearchResponse, error) {
    // 构建ES查询
    searchBody := map[string]interface{}{
        "query": s.buildESQuery(query, req.Filters),
        "sort":  s.buildESSort(req.Sort),
        "from":  (req.Page - 1) * req.Size,
        "size":  req.Size,
        "aggs":  s.buildESAggregations(req.Filters),
        "highlight": map[string]interface{}{
            "fields": map[string]interface{}{
                "product_name": map[string]interface{}{},
                "description":  map[string]interface{}{},
            },
        },
    }
    
    // 执行查询
    body, _ := json.Marshal(searchBody)
    resp, err := s.esClient.Search(
        s.esClient.Search.WithContext(ctx),
        s.esClient.Search.WithIndex("products"),
        s.esClient.Search.WithBody(strings.NewReader(string(body))),
        s.esClient.Search.WithTimeout(5*time.Second),
    )
    
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    // 解析结果
    return s.parseESResponse(resp)
}

// 构建ES查询
func (s *SearchService) buildESQuery(query string, filters map[string]interface{}) map[string]interface{} {
    mustClauses := []map[string]interface{}{}
    filterClauses := []map[string]interface{}{}
    
    // 主查询
    if query != "" {
        mustClauses = append(mustClauses, map[string]interface{}{
            "multi_match": map[string]interface{}{
                "query": query,
                "fields": []string{
                    "product_name^3",    // 商品名称权重最高
                    "brand^2",           // 品牌权重次之
                    "category_name^1.5", // 分类权重
                    "description",       // 描述权重最低
                },
                "type": "best_fields",
                "operator": "and",
            },
        })
    }
    
    // 过滤条件
    for key, value := range filters {
        switch key {
        case "category_id":
            filterClauses = append(filterClauses, map[string]interface{}{
                "term": map[string]interface{}{
                    "category_id": value,
                },
            })
        case "brand_id":
            filterClauses = append(filterClauses, map[string]interface{}{
                "term": map[string]interface{}{
                    "brand_id": value,
                },
            })
        case "price_range":
            priceRange := value.(map[string]float64)
            filterClauses = append(filterClauses, map[string]interface{}{
                "range": map[string]interface{}{
                    "sale_price": map[string]interface{}{
                        "gte": priceRange["min"],
                        "lte": priceRange["max"],
                    },
                },
            })
        }
    }
    
    // 商品状态过滤
    filterClauses = append(filterClauses, map[string]interface{}{
        "term": map[string]interface{}{
            "status": 1, // 只搜索上架商品
        },
    })
    
    return map[string]interface{}{
        "bool": map[string]interface{}{
            "must":   mustClauses,
            "filter": filterClauses,
        },
    }
}

// 个性化处理
func (s *SearchService) applyPersonalization(ctx context.Context, resp *SearchResponse, req *SearchRequest) (*SearchResponse, error) {
    if req.UserID == 0 {
        return resp, nil // 未登录用户不做个性化
    }
    
    // 获取用户画像
    profile, err := s.personalSvc.GetUserProfile(ctx, req.UserID)
    if err != nil {
        return resp, nil // 获取失败则不做个性化
    }
    
    // 重新排序
    s.reorderByPersonalization(resp.Products, profile)
    
    // 混入推荐商品
    recommendations, _ := s.personalSvc.GetRecommendations(ctx, req.UserID, 5)
    resp.Products = s.mixRecommendations(resp.Products, recommendations)
    
    return resp, nil
}

// 实时数据补充
func (s *SearchService) enrichWithRealTimeData(ctx context.Context, resp *SearchResponse) (*SearchResponse, error) {
    skuIDs := make([]int64, len(resp.Products))
    for i, product := range resp.Products {
        skuIDs[i] = product.SkuID
    }
    
    // 批量获取实时价格
    prices, err := s.batchGetPrices(ctx, skuIDs)
    if err != nil {
        log.Errorf("Failed to get real-time prices: %v", err)
    }
    
    // 批量获取实时库存
    inventories, err := s.batchGetInventories(ctx, skuIDs)
    if err != nil {
        log.Errorf("Failed to get real-time inventories: %v", err)
    }
    
    // 更新商品信息
    for i := range resp.Products {
        if price, exists := prices[resp.Products[i].SkuID]; exists {
            resp.Products[i].SalePrice = price.SalePrice
            resp.Products[i].OriginalPrice = price.OriginalPrice
        }
        
        if inventory, exists := inventories[resp.Products[i].SkuID]; exists {
            resp.Products[i].AvailableStock = inventory.AvailableStock
        }
    }
    
    return resp, nil
}
```

### 4.2 缓存实现

```go
// 多级缓存实现
type MultiLevelCache struct {
    l1Cache *cache.Cache      // 本地缓存
    l2Cache *redis.Client     // Redis缓存
    l3Cache func(string) interface{} // 数据源
}

func (mlc *MultiLevelCache) Get(key string) (interface{}, error) {
    // L1缓存查询
    if value, found := mlc.l1Cache.Get(key); found {
        return value, nil
    }
    
    // L2缓存查询
    value, err := mlc.l2Cache.Get(context.Background(), key).Result()
    if err == nil {
        // 回写L1缓存
        mlc.l1Cache.Set(key, value, cache.DefaultExpiration)
        return value, nil
    }
    
    // L3数据源查询
    value = mlc.l3Cache(key)
    if value != nil {
        // 回写L2和L1缓存
        mlc.l2Cache.Set(context.Background(), key, value, time.Hour)
        mlc.l1Cache.Set(key, value, 10*time.Minute)
    }
    
    return value, nil
}

// 搜索结果缓存策略
func (s *SearchService) generateCacheKey(req *SearchRequest) string {
    h := sha256.New()
    h.Write([]byte(fmt.Sprintf("%s:%v:%v:%d:%d", 
        req.Query, req.Filters, req.Sort, req.Page, req.Size)))
    return fmt.Sprintf("search:%x", h.Sum(nil))
}

func (s *SearchService) getFromCache(ctx context.Context, key string) (*SearchResponse, error) {
    value, err := s.localCache.Get(key)
    if err == nil {
        if resp, ok := value.(*SearchResponse); ok {
            return resp, nil
        }
    }
    
    // Redis缓存
    data, err := s.redis.Get(ctx, key).Bytes()
    if err != nil {
        return nil, err
    }
    
    var resp SearchResponse
    if err := json.Unmarshal(data, &resp); err != nil {
        return nil, err
    }
    
    // 回写本地缓存
    s.localCache.Set(key, &resp, 5*time.Minute)
    
    return &resp, nil
}
```

### 4.3 性能优化

```go
// 搜索性能优化
type SearchOptimizer struct {
    rateLimiter  *rate.Limiter
    circuitBreaker *breaker.CircuitBreaker
    metrics      *SearchMetrics
}

// 限流处理
func (so *SearchOptimizer) RateLimit(userID int64) error {
    if !so.rateLimiter.Allow() {
        so.metrics.RateLimitCounter.Inc()
        return errors.New("rate limit exceeded")
    }
    return nil
}

// 熔断处理
func (so *SearchOptimizer) ExecuteWithCircuitBreaker(fn func() error) error {
    return so.circuitBreaker.Execute(fn)
}

// 并发搜索优化
func (s *SearchService) ConcurrentSearch(ctx context.Context, queries []SearchRequest) ([]*SearchResponse, error) {
    results := make([]*SearchResponse, len(queries))
    errors := make([]error, len(queries))
    
    var wg sync.WaitGroup
    semaphore := make(chan struct{}, 10) // 限制并发数
    
    for i, query := range queries {
        wg.Add(1)
        go func(index int, req SearchRequest) {
            defer wg.Done()
            
            semaphore <- struct{}{}
            defer func() { <-semaphore }()
            
            result, err := s.Search(ctx, &req)
            results[index] = result
            errors[index] = err
        }(i, query)
    }
    
    wg.Wait()
    
    // 检查是否有错误
    for _, err := range errors {
        if err != nil {
            return results, err
        }
    }
    
    return results, nil
}
```

---

## 5. 搜索运营与监控

### 5.1 搜索质量监控

```mermaid
graph TB
    A[搜索质量监控] --> B[相关性监控]
    A --> C[用户行为监控]
    A --> D[业务指标监控]
    
    B --> B1[点击率CTR]
    B --> B2[转化率CVR]
    B --> B3[停留时间]
    
    C --> C1[搜索跳出率]
    C --> C2[重复搜索率]
    C --> C3[零结果搜索率]
    
    D --> D1[搜索GMV]
    D --> D2[搜索订单量]
    D --> D3[搜索用户数]
```

### 5.2 搜索运营策略

```mermaid
flowchart TD
    A[搜索运营] --> B[搜索词优化]
    A --> C[搜索结果优化]
    A --> D[用户体验优化]
    
    B --> B1[热词分析]
    B --> B2[长尾词优化]
    B --> B3[无结果词优化]
    
    C --> C1[排序策略调整]
    C --> C2[相关性优化]
    C --> C3[个性化优化]
    
    D --> D1[搜索建议优化]
    D --> D2[搜索响应速度]
    D --> D3[搜索界面优化]
```

---

## 验收标准

### 功能验收标准
- [ ] 支持全文搜索、分类搜索、筛选搜索
- [ ] 搜索建议和自动补全功能
- [ ] 个性化搜索排序
- [ ] 搜索结果高亮显示
- [ ] 多维度聚合统计

### 性能验收标准
- [ ] 搜索响应时间P99 < 200ms
- [ ] 搜索QPS > 10万
- [ ] 缓存命中率 > 90%
- [ ] 搜索可用性 > 99.9%
- [ ] 并发用户 > 100万

### 质量验收标准
- [ ] 搜索相关性准确率 > 85%
- [ ] 搜索零结果率 < 5%
- [ ] 搜索CTR > 15%
- [ ] 搜索转化率 > 3%
- [ ] 搜索跳出率 < 40%